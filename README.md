# Binary_To_Gray_Code_Converter

  * [Abstract](#abstract)
  * [Reference Truth Table](#reference-truth-table)
  * [Modification of Equations](#Minimized_Equations)
  * [Formation of Minimized Circuit](#Minimized_Circuit)
  * [Tools Used](#tools-used)
- [Simulation in ESIM](#simulation-in-esim)
  * [Verilog_Code](#verilog_code)
  * [Makerchip_Block](#makerchip_block)
  * [Schematic_Model](#schematic_model)
  * [Netlist](#netlist)
  * [Waveforms](#waveforms)
  * [Using_Gaw](#using_gaw)
  * [Conclusion](#conclusion)
  * [Author](#author)
  * [Acknowledgement](#acknowlegement)
  * [References](#references)


## Abstract
Gray Code system is a binary number system in which every successive pair of numbers differs in only one bit. It is used in applications in which the normal sequence of binary numbers generated by the hardware may produce an error or ambiguity during the transition from one number to the next.Gray code – also known as Cyclic Code, Reflected Binary Code (RBC), Reflected Binary (RB) or Grey code – is defined as an ordering of the binary number system such that each incremental value can only differ by one bit. In gray code, while traversing from one step to another step only one bit in the code group changes. That is to say that two adjacent code numbers differ from each other by only one bit.

Gray code is the most popular of the unit distance codes, but it is not suitable for arithmetic operations. Gray code has some applications in analog to digital converters, as well as being used for error correction in digital communication.

## Reference Truth Table

![IMG_20220405_155250](https://user-images.githubusercontent.com/59500283/161821480-1f06e8c3-1ecf-4aae-b8e9-f5c283aded76.jpg)


## Minimized Equations

![IMG_20220405_162058](https://user-images.githubusercontent.com/59500283/161821592-86df7a61-3f95-4efa-8b93-4131234bca7f.jpg)

![IMG_20220405_162148](https://user-images.githubusercontent.com/59500283/161821638-50d19ca7-05ff-4fae-90f6-82c13ff68fe6.jpg)


## Minimized Circuit 

![IMG_20220405_152809](https://user-images.githubusercontent.com/59500283/161822051-b5780ba1-e1e2-468b-817b-4463560a1b33.jpg)


## Tools Used:

![NGSPICE](https://user-images.githubusercontent.com/59500283/161823202-f5325839-fe04-4437-842a-f9432029402c.jpeg)
![Microwind](https://user-images.githubusercontent.com/59500283/161823254-2cd4a00b-dc74-4414-9fdf-7bda42d83534.jpeg)


## Simulation in NGSPICE

Formation of Netlist For the Required Circuits.

Step-1 : Numbering the Elements According to the rules.

![IMG_20220405_164759](https://user-images.githubusercontent.com/59500283/161823729-73c7d250-7a6d-4515-a705-51c0529aff2b.jpg)


Step-2 : Recognize the Sub-Circuits and Writing Netlist for them.

![IMG_20220405_165339](https://user-images.githubusercontent.com/59500283/161823787-3868b128-9a02-4584-a8a3-b5908d8751b4.jpg)


## Netlist



## Makerchip_Block
<img width="1440" alt="Screenshot 2022-03-07 at 8 43 52 PM" src="https://user-images.githubusercontent.com/59500283/157091147-2f2f0d22-ba91-4351-9cd7-7bc3939535d7.png">


Using NGVeri and the above Verilog Code We Create the 3_Bit_Wallace Model.

## Schematic_Model

The Mixed Signal Circuit is made up of Two Parts Digital and Analog.
In this case the Wallace Model is Digital Part and the ADC DAC Bridge is Analog Part in the Schematic.

<img width="1346" alt="Screenshot 2022-03-07 at 8 04 00 PM" src="https://user-images.githubusercontent.com/59500283/157094037-2ddcece6-f239-4c77-9935-6e3b7d5460d0.png">

After Drawing the Schematic we generate a netlist and then we use a KICAD to NGSPICE Converter

## Netlist

* /home/bt19ece016/esim-workspace/wallace/wallace.cir

* u2  net-_u2-pad1_ net-_u2-pad2_ net-_u2-pad3_ net-_u2-pad4_ net-_u2-pad5_ net-_u2-pad6_ net-_u2-pad7_ net-_u2-pad8_ net-_u2-pad9_ net-_u2-pad10_ net-_u2-pad11_ net-_u2-pad12_ mayur_wallace
* u8  a2 a1 a0 b2 b1 b0 net-_u2-pad1_ net-_u2-pad2_ net-_u2-pad3_ net-_u2-pad4_ net-_u2-pad5_ net-_u2-pad6_ adc_bridge_6
v1  a2 gnd pulse(0 5 0 0.1m 0.1m 5 10)
v2  a1 gnd pulse(0 5 0 0.1m 0.1m 10 20)
v3  a0 gnd pulse(0 5 0 0.1m 0.1m 20 40)
v4  b2 gnd pulse(0 5 0 0.1m 0.1m 5 10)
v5  b1 gnd pulse(0 5 0 0.1m 0.1m 10 20)
v6  b0 gnd pulse(0 5 0 0.1m 0.1m 20 40)
* u1  a2 plot_v1
* u3  a1 plot_v1
* u4  a0 plot_v1
* u5  b2 plot_v1
* u6  b1 plot_v1
* u7  b0 plot_v1
c2  prod1 gnd 1u
c4  prod3 gnd 1u
c6  prod5 gnd 1u
r2  net-_r2-pad1_ prod1 1k
r4  net-_r4-pad1_ prod3 1k
r6  net-_r6-pad1_ prod5 1k
* u15  prod5 plot_v1
* u13  prod3 plot_v1
* u11  prod1 plot_v1
* u9  net-_u2-pad7_ net-_u2-pad8_ net-_u2-pad9_ net-_u2-pad10_ net-_u2-pad11_ net-_u2-pad12_ net-_r6-pad1_ net-_r5-pad1_ net-_r4-pad1_ net-_r3-pad1_ net-_r2-pad1_ net-_r1-pad1_ dac_bridge_6
c1  prod0 gnd 1u
r1  net-_r1-pad1_ prod0 1k
* u10  prod0 plot_v1
r5  net-_r5-pad1_ prod4 1k
c5  prod4 gnd 1u
* u14  prod4 plot_v1
c3  prod2 gnd 1u
r3  net-_r3-pad1_ prod2 1k
* u12  prod2 plot_v1
a1 [net-_u2-pad1_ net-_u2-pad2_ net-_u2-pad3_ ] [net-_u2-pad4_ net-_u2-pad5_ net-_u2-pad6_ ] [net-_u2-pad7_ net-_u2-pad8_ net-_u2-pad9_ net-_u2-pad10_ net-_u2-pad11_ net-_u2-pad12_ ] u2
a2 [a2 a1 a0 b2 b1 b0 ] [net-_u2-pad1_ net-_u2-pad2_ net-_u2-pad3_ net-_u2-pad4_ net-_u2-pad5_ net-_u2-pad6_ ] u8
a3 [net-_u2-pad7_ net-_u2-pad8_ net-_u2-pad9_ net-_u2-pad10_ net-_u2-pad11_ net-_u2-pad12_ ] [net-_r6-pad1_ net-_r5-pad1_ net-_r4-pad1_ net-_r3-pad1_ net-_r2-pad1_ net-_r1-pad1_ ] u9
* Schematic Name:                             mayur_wallace, NgSpice Name: mayur_wallace
.model u2 mayur_wallace(rise_delay=1.0e-9 fall_delay=1.0e-9 input_load=1.0e-12 instance_id=1 ) 
* Schematic Name:                             adc_bridge_6, NgSpice Name: adc_bridge
.model u8 adc_bridge(in_low=1.0 in_high=2.0 rise_delay=1.0e-9 fall_delay=1.0e-9 ) 
* Schematic Name:                             dac_bridge_6, NgSpice Name: dac_bridge
.model u9 dac_bridge(out_low=0.0 out_high=5.0 out_undef=0.5 input_load=1.0e-12 t_rise=1.0e-9 t_fall=1.0e-9 ) 
.tran 0.1e-00 40e-00 0e-00

* Control Statements 
.control
run
print allv > plot_data_v.txt
print alli > plot_data_i.txt
plot v(a2) v(a1)+6 v(a0)+12 v(b2)+18 v(b1)+2 v(b0)+30 v(prod5)+36 v(prod3)+42 v(prod1)+48 v(prod0)+54 v(prod4)+60 v(prod2)+66
.endc
.end


## Waveforms
<img width="1340" alt="Screenshot 2022-03-07 at 8 06 01 PM" src="https://user-images.githubusercontent.com/59500283/157094948-38474f65-1df7-495b-a86c-1bbf85e27c6e.png">

Using GAW We Plot a0,a1,a2,b0,b1,b2,prod0,prod1,prod2,prod3,prod4,prod5 in Different Planes.
## Using_GAW
<img width="1436" alt="Screenshot 2022-03-07 at 8 11 04 PM" src="https://user-images.githubusercontent.com/59500283/157095200-ae6d6039-8e81-41bd-8fa2-8e8540c6e32c.png">
<img width="1439" alt="Screenshot 2022-03-07 at 8 27 15 PM" src="https://user-images.githubusercontent.com/59500283/157095226-568362ab-c78c-484a-a63f-73b3c89b98c1.png">


## Conclusion
Thus ,The Multiplication for a Two 3_Bit Numbers is achieved using Wallace Multiplier.

## Author
Mayur Dongre , Indian Institute of Information Technoology Nagpur.
## Acknowledgement
1. Kunal Ghosh, Co-founder, VSD Corp. Pvt. Ltd. - kunalpghosh@gmail.com
2. Sameer Durgoji, NIT Karnataka
3. https://esim.marathoniitb.in/
## References
  1)Wikipedia-https://en.wikipedia.org/wiki/Wallace_tree

  2)Youtube Video -https://www.youtube.com/watch?v=lcPIMvI57dM&t=114s

  3)PriyankaMishraandSeemaNayak.AStudyon Wallace Tree Multiplier. https://www.researchgate.net/publication/32720922 

  
